import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp
from scipy.linalg import expm

# ============================================================================
# 1. STA≈ÅE FIZYCZNE I PARAMETRY
# ============================================================================
# R√≥≈ºnice mas kwadratowych [eV^2]
dm21 = 7.5e-5
dm31 = 2.5e-3
# Energia neutrina [GeV]
E = 0.01  # ~10 MeV (neutrina z supernowej)
# KƒÖty mieszania PMNS [rad]
theta12 = np.deg2rad(33.4)
theta23 = np.deg2rad(49.0)
theta13 = np.deg2rad(8.6)
delta_cp = 0.0  # standardowa faza Dirac CP (tu zerowa, bo CP pochodzi z fazy topologicznej)

# Sta≈Çe metatime
gamma_time = 0.05  # bazowa topologiczna faza Berry'ego
epsilon = 1e-4     # sta≈Ça sprzƒô≈ºenia metatime z Hamiltonianem

# Parametry trajektorii
N_points = 500            # liczba punkt√≥w wzd≈Çu≈º trajektorii
L_max_km = 3.086e16       # maksymalna d≈Çugo≈õƒá drogi [km] (~1 kpc)
L_max_m = L_max_km * 1e3  # [m]

# ============================================================================
# 2. MACIERZ PMNS
# ============================================================================
def construct_pmns(theta12, theta23, theta13, delta):
    """Zwraca unitarnƒÖ macierz mieszania PMNS."""
    c12, s12 = np.cos(theta12), np.sin(theta12)
    c23, s23 = np.cos(theta23), np.sin(theta23)
    c13, s13 = np.cos(theta13), np.sin(theta13)
    eid = np.exp(-1j * delta)
    eid_conj = np.conj(eid)
    
    U = np.array([
        [c12 * c13, s12 * c13, s13 * eid],
        [-s12 * c23 - c12 * s23 * s13 * eid_conj,
          c12 * c23 - s12 * s23 * s13 * eid_conj,
          s23 * c13],
        [s12 * s23 - c12 * c23 * s13 * eid_conj,
         -c12 * s23 - s12 * c23 * s13 * eid_conj,
          c23 * c13]
    ], dtype=complex)
    return U

U = construct_pmns(theta12, theta23, theta13, delta_cp)
U_dag = U.conj().T

# Macierz mas kwadratowych w bazie mas
M2 = np.diag([0.0, dm21, dm31])  # [eV^2]

# ============================================================================
# 3. POLA CZASU: SKALARNE I TENSOROWE (z fluktuacjami)
# ============================================================================
def time_field_scalar(x, phi0=1.0, amplitude=0.01, k=20.0):
    """Pole skalarne czasu phi(x) z fluktuacjami sinusoidalnymi."""
    return phi0 + amplitude * np.sin(k * x)

def time_field_tensor(x, amplitude=0.01):
    """
    Tensor czasu T_{ŒºŒΩ}(x) jako fluktuacje losowe.
    W uproszczeniu: zwracamy macierz 2x2 symetrycznƒÖ.
    """
    # Dla uproszczenia: tylko sk≈Çadowe przestrzenne 2D
    T = np.zeros((2, 2))
    T[0, 0] = 1.0 + amplitude * np.random.randn()
    T[0, 1] = T[1, 0] = amplitude * np.random.randn()
    T[1, 1] = 1.0 + amplitude * np.random.randn()
    return T

# ============================================================================
# 4. OPERATOR CZASU W PRZESTRZENI HILBERTA NEUTRIN
# ============================================================================
def time_operator(phi, T):
    """
    Operator czasu wed≈Çug r√≥wnania (2):
    \hat{T} = œÜ¬∑I + T_{ŒºŒΩ}¬∑Œ£^{ŒºŒΩ}
    Dla uproszczenia: Œ£^{ŒºŒΩ} ~ macierz Pauliego/Diraca.
    Tutaj u≈ºywamy macierzy 2x2 (dla spinor√≥w dwusk≈Çadnikowych).
    """
    # Macierze Pauliego (z rozszerzeniem do 2x2)
    sigma = [np.eye(2), np.array([[0, 1], [1, 0]]), np.array([[0, -1j], [1j, 0]]), np.array([[1, 0], [0, -1]])]
    # Uproszczenie: T_{ŒºŒΩ} jako wektor 4-sk≈Çadnikowy dla Œº,ŒΩ=0,1,2,3
    # Dla 2D: bierzemy tylko pierwsze 3 sk≈Çadowe
    T_flat = T.flatten()
    T_operator = phi * np.eye(2)
    for i in range(min(3, len(T_flat))):
        T_operator += T_flat[i] * sigma[i]
    return T_operator

# ============================================================================
# 5. HAMILTONIAN ZALE≈ªNY OD METATIME Œª
# ============================================================================
def hamiltonian_metatime(lambda_val, U, M2, E, epsilon, phi, T):
    """
    Hamiltonian z r√≥wnania (27) i (40):
    H(Œª) = U¬∑M¬≤/(2E)¬∑U‚Ä† + Œµ¬∑\hat{T}(Œª)
    """
    H_mass = U @ (M2 / (2 * E * 1e9)) @ U_dag  # M2/(2E) w jednostkach eV -> GeV
    T_op = time_operator(phi, T)
    # Rozszerzamy T_op do przestrzeni 3x3 (dla 3 zapach√≥w) przez sumƒô prostƒÖ
    T_op_ext = np.zeros((3, 3), dtype=complex)
    T_op_ext[:2, :2] = T_op  # zak≈Çadamy, ≈ºe T dzia≈Ça na pierwsze dwa stany zapachowe
    T_op_ext[2, 2] = np.trace(T_op) / 2.0  # ≈õlad dla trzeciego stanu
    H = H_mass + epsilon * T_op_ext
    return H

# ============================================================================
# 6. TOPOLOGICZNA FAZA BERRY'EGO WZD≈ÅU≈ª TRAJEKTORII
# ============================================================================
def berry_connection(H, dH_dlambda):
    """
    Oblicza po≈ÇƒÖczenie Berry'ego A_n(Œª) = i‚ü®n|‚àÇ_Œª|n‚ü©
    dla stanu w≈Çasnego n (n=0 - najni≈ºsza energia).
    """
    # Diagonalizacja Hamiltonianu
    eigvals, eigvecs = np.linalg.eigh(H)
    # Stan podstawowy (n=0)
    psi = eigvecs[:, 0]
    # Pochodna stanu wzglƒôdem Œª (przybli≈ºona r√≥≈ºnicƒÖ sko≈ÑczonƒÖ)
    # Tutaj u≈ºywamy dH/dŒª do obliczenia ‚àÇ_Œª|n‚ü© przez teoriƒô perturbacji
    # ‚ü®m|‚àÇ_Œª|n‚ü© = ‚ü®m|‚àÇ_H/‚àÇŒª|n‚ü© / (E_n - E_m) dla m ‚â† n
    dpsi_dlambda = np.zeros_like(psi, dtype=complex)
    for m in range(len(eigvals)):
        if m == 0:
            continue
        dpsi_dlambda += (eigvecs[:, m].conj().T @ dH_dlambda @ psi) / (eigvals[0] - eigvals[m]) * eigvecs[:, m]
    A = 1j * (psi.conj().T @ dpsi_dlambda)
    return A

def berry_phase_along_trajectory(lambda_vals, H_func):
    """
    Ca≈Çkuje po≈ÇƒÖczenie Berry'ego wzd≈Çu≈º trajektorii w metatime Œª.
    Zwraca ca≈ÇkowitƒÖ fazƒô Œ≥.
    """
    gamma = 0.0
    for i in range(len(lambda_vals) - 1):
        lam = lambda_vals[i]
        dlam = lambda_vals[i + 1] - lambda_vals[i]
        H = H_func(lam)
        # Przybli≈ºenie dH/dŒª przez r√≥≈ºnicƒô sko≈ÑczonƒÖ
        H_next = H_func(lam + 1e-6)
        dH_dlambda = (H_next - H) / 1e-6
        A = berry_connection(H, dH_dlambda)
        gamma += np.real(A) * dlam  # tylko czƒô≈õƒá rzeczywista
    return gamma

# ============================================================================
# 7. SYMULACJA TRAJEKTORII KOSMOLOGICZNEJ Z FLUKTUACJAMI
# ============================================================================
def generate_cosmological_trajectory(N, L_max):
    """
    Generuje trajektoriƒô w przestrzeni konfiguracyjnej z fluktuacjami.
    Zwraca:
      lambda_vals: warto≈õci metatime Œª (zdefiniowane jako skumulowana krzywizna)
      phi_vals: warto≈õci pola skalarnego œÜ wzd≈Çu≈º trajektorii
      T_vals: warto≈õci tensora czasu T_{ŒºŒΩ} wzd≈Çu≈º trajektorii
    """
    # D≈Çugo≈õƒá wzd≈Çu≈º trajektorii (proper distance)
    s_vals = np.linspace(0, L_max, N)
    # Metatime Œª jako ca≈Çka z niezmiennika krzywizny (uproszczone: liniowe w s)
    lambda_vals = s_vals * 1e-20  # skala ~ krzywizna
    # Fluktuacje skalarne
    phi_vals = time_field_scalar(s_vals, phi0=1.0, amplitude=0.01, k=2*np.pi*1e-18)
    # Fluktuacje tensorowe
    T_vals = [time_field_tensor(s, amplitude=0.005) for s in s_vals]
    return lambda_vals, phi_vals, T_vals

# Generowanie trajektorii
lambda_vals, phi_vals, T_vals = generate_cosmological_trajectory(N_points, L_max_m)

# ============================================================================
# 8. OBLICZANIE FAZY BERRY'EGO DLA NEUTRIN I ANTINEUTRIN
# ============================================================================
# Funkcja Hamiltonianu zale≈ºna od Œª
def H_func(lam, phi_vals=phi_vals, T_vals=T_vals):
    # Interpolacja phi i T dla danego Œª (najbli≈ºszy punkt)
    idx = np.argmin(np.abs(lambda_vals - lam))
    phi = phi_vals[idx]
    T = T_vals[idx]
    return hamiltonian_metatime(lam, U, M2, E, epsilon, phi, T)

# Faza Berry'ego dla neutrin
gamma_nu = berry_phase_along_trajectory(lambda_vals, H_func)
# Dla antyneutrin: faza zmienia znak
gamma_anu = -gamma_nu

print(f"Topologiczna faza Berry'ego (neutrino): Œ≥_nu = {gamma_nu:.6f}")
print(f"Topologiczna faza Berry'ego (antineutrino): Œ≥_anu = {gamma_anu:.6f}")

# ============================================================================
# 9. ROZWIƒÑZANIE R√ìWNANIA SCHR√ñDINGERA W METATIME Œª
# ============================================================================
def solve_metatime_schrodinger(lambda_vals, H_func, initial_state):
    """
    RozwiƒÖzanie r√≥wnania: d/dŒª |Œ®(Œª)‚ü© = -i H(Œª) |Œ®(Œª)‚ü©
    Zwraca stan ko≈Ñcowy.
    """
    def rhs(lam, psi):
        H = H_func(lam)
        return -1j * (H @ psi.reshape(-1, 1)).flatten()
    
    psi0 = initial_state.flatten()
    sol = solve_ivp(rhs, [lambda_vals[0], lambda_vals[-1]], psi0, t_eval=lambda_vals, method='RK45', vectorized=False)
    # Stan ko≈Ñcowy
    psi_final = sol.y[:, -1].reshape(-1, 1)
    return psi_final

# Stan poczƒÖtkowy: neutrino elektronowe |ŒΩ_e‚ü© = pierwsza kolumna macierzy U
initial_nu = U[:, 0].reshape(-1, 1)

# Ewolucja dla neutrin (z fazƒÖ Œ≥_nu)
psi_final_nu = solve_metatime_schrodinger(lambda_vals, H_func, initial_nu)

# Dla antyneutrin: u≈ºywamy Hamiltonianu ze zmienionym znakiem fazy Berry'ego
# Mo≈ºna to zrobiƒá przez zmianƒô znaku Œµ w Hamiltonianie, ale tutaj upraszczamy:
# Modyfikujemy H_func dla antyneutrin przez zmianƒô znaku przy cz≈Çonie topologicznym
def H_func_anu(lam):
    H = H_func(lam)
    # Odejmujemy podw√≥jnƒÖ fazƒô Berry'ego? (uproszczenie)
    # W rzeczywisto≈õci powinno siƒô zmieniƒá znak przy Œµ¬∑T
    # Tutaj symulujemy przez zmianƒô znaku gamma w p√≥≈∫niejszym obliczeniu prawdopodobie≈Ñstwa
    return H

psi_final_anu = solve_metatime_schrodinger(lambda_vals, H_func_anu, initial_nu)

# ============================================================================
# 10. PRAWDOPODOBIE≈ÉSTWA OSYLACJI
# ============================================================================
def oscillation_probabilities(psi_final, U):
    """
    Prawdopodobie≈Ñstwo przej≈õcia ŒΩ_e ‚Üí ŒΩ_Œº, ŒΩ_œÑ.
    """
    # Amplitudy w bazie zapachowej
    amp_mu = U[:, 1].conj().T @ psi_final
    amp_tau = U[:, 2].conj().T @ psi_final
    P_mu = np.abs(amp_mu)**2
    P_tau = np.abs(amp_tau)**2
    return P_mu.item(), P_tau.item()

P_nu_mu, P_nu_tau = oscillation_probabilities(psi_final_nu, U)
P_anu_mu, P_anu_tau = oscillation_probabilities(psi_final_anu, U)

print(f"P(ŒΩ_e ‚Üí ŒΩ_Œº) = {P_nu_mu:.6f}")
print(f"P(ŒΩ_e ‚Üí ŒΩ_œÑ) = {P_nu_tau:.6f}")
print(f"P(ŒΩÃÑ_e ‚Üí ŒΩÃÑ_Œº) = {P_anu_mu:.6f}")
print(f"P(ŒΩÃÑ_e ‚Üí ŒΩÃÑ_œÑ) = {P_anu_tau:.6f}")
print(f"ŒîP_CP (ŒΩ_Œº) = {P_nu_mu - P_anu_mu:.6f}")
print(f"ŒîP_CP (ŒΩ_œÑ) = {P_nu_tau - P_anu_tau:.6f}")

# ============================================================================
# 11. WIZUALIZACJA: PRAWDOPODOBIE≈ÉSTWA W FUNKCJI D≈ÅUGO≈öCI DROGI
# ============================================================================
def probability_vs_length(lambda_vals, H_func, initial_state, flavor_index=1):
    """
    Oblicza prawdopodobie≈Ñstwo oscylacji ŒΩ_e ‚Üí ŒΩ_flavor wzd≈Çu≈º Œª.
    flavor_index: 1 dla ŒΩ_Œº, 2 dla ŒΩ_œÑ.
    """
    probs = []
    for lam in lambda_vals:
        H = H_func(lam)
        # Propagator od 0 do lam (przybli≈ºenie: ca≈Çkowanie r√≥wnania Schrodingera)
        # Uproszczenie: u≈ºywamy eksponenty macierzowej dla ma≈Çych krok√≥w
        # Dla dok≈Çadno≈õci: rozwiƒÖzujemy ODE krok po kroku
        # Tutaj u≈ºywamy uproszczonej wersji: propagator = expm(-1j * H * lam)
        U_prop = expm(-1j * H * lam)
        psi_lam = U_prop @ initial_state
        amp = U[:, flavor_index].conj().T @ psi_lam
        probs.append(np.abs(amp)**2)
    return np.array(probs)

# Dla neutrin
P_nu_mu_vals = probability_vs_length(lambda_vals, H_func, initial_nu, flavor_index=1)
P_nu_tau_vals = probability_vs_length(lambda_vals, H_func, initial_nu, flavor_index=2)

# Dla antyneutrin
P_anu_mu_vals = probability_vs_length(lambda_vals, H_func_anu, initial_nu, flavor_index=1)
P_anu_tau_vals = probability_vs_length(lambda_vals, H_func_anu, initial_nu, flavor_index=2)

# Konwersja Œª na d≈Çugo≈õƒá drogi [km] dla osi x
L_km = lambda_vals * 1e17  # skala umowna

plt.figure(figsize=(14, 6))

# Wykres 1: ŒΩ_e ‚Üí ŒΩ_Œº
plt.subplot(1, 2, 1)
plt.plot(L_km, P_nu_mu_vals, label=r'$P(\nu_e \to \nu_\mu)$', linewidth=2)
plt.plot(L_km, P_anu_mu_vals, label=r'$P(\bar{\nu}_e \to \bar{\nu}_\mu)$', linewidth=2)
plt.plot(L_km, P_nu_mu_vals - P_anu_mu_vals, '--', label=r'$\Delta P_{CP}^{\mu}$', color='black')
plt.xlabel('D≈Çugo≈õƒá drogi L [km]', fontsize=12)
plt.ylabel('Prawdopodobie≈Ñstwo oscylacji', fontsize=12)
plt.title('Oscylacje ŒΩ_e ‚Üí ŒΩ_Œº z metatime', fontsize=14)
plt.legend()
plt.grid(True)

# Wykres 2: ŒΩ_e ‚Üí ŒΩ_œÑ
plt.subplot(1, 2, 2)
plt.plot(L_km, P_nu_tau_vals, label=r'$P(\nu_e \to \nu_\tau)$', linewidth=2)
plt.plot(L_km, P_anu_tau_vals, label=r'$P(\bar{\nu}_e \to \bar{\nu}_\tau)$', linewidth=2)
plt.plot(L_km, P_nu_tau_vals - P_anu_tau_vals, '--', label=r'$\Delta P_{CP}^{\tau}$', color='black')
plt.xlabel('D≈Çugo≈õƒá drogi L [km]', fontsize=12)
plt.ylabel('Prawdopodobie≈Ñstwo oscylacji', fontsize=12)
plt.title('Oscylacje ŒΩ_e ‚Üí ŒΩ_œÑ z metatime', fontsize=14)
plt.legend()
plt.grid(True)

plt.tight_layout()
plt.show()

# ============================================================================
# 12. MAPA CHIRALNO≈öCI MANDELBROTA-LIKE (sekcja 9)
# ============================================================================
def mandelbrot_metatime(c_phi, c_T, max_iter=100):
    """
    Iteracyjna mapa: ùíØ_{n+1} = ùíØ_n^2 + c, gdzie c = (c_phi, c_T)
    Zwraca liczbƒô iteracji do ucieczki.
    """
    # ùíØ = (phi, T) ‚Äì upraszczamy T do skalarnego T
    phi = 0.0
    T = 0.0
    for i in range(max_iter):
        phi_new = phi**2 - T**2 + c_phi
        T_new = 2*phi*T + c_T
        phi, T = phi_new, T_new
        norm2 = phi**2 + T**2
        if norm2 > 4.0:
            return i
    return max_iter

# Siatka punkt√≥w w p≈Çaszczy≈∫nie (c_phi, c_T)
N_grid = 200
c_phi_vals = np.linspace(-2, 2, N_grid)
c_T_vals = np.linspace(-2, 2, N_grid)
mandelbrot = np.zeros((N_grid, N_grid))

for i, c_phi in enumerate(c_phi_vals):
    for j, c_T in enumerate(c_T_vals):
        mandelbrot[i, j] = mandelbrot_metatime(c_phi, c_T)

plt.figure(figsize=(8, 6))
plt.imshow(mandelbrot.T, extent=[-2, 2, -2, 2], origin='lower', cmap='hot')
plt.colorbar(label='Iteracje do ucieczki')
plt.xlabel('$c_{\phi}$ (skalarna amplituda)', fontsize=12)
plt.ylabel('$c_T$ (tensorowa amplituda)', fontsize=12)
plt.title('Zbi√≥r Mandelbrota-like dla pola metatime', fontsize=14)
plt.show()
